Let's talk about what a Kubernetes operator is, why this operator concept even emerged, 
and when you should use operators.

To give you an overview, operators are used mainly for stateful applications. We'll first compare how Kubernetes manages stateless and stateful applications and then compare deploying and managing stateful applications without an operator versus deploying them with a Kubernetes operator.


Let's go through an example use case for stateless applications on Kubernetes. Let's say we are deploying an example web application in a Kubernetes cluster. You create a deployment, a config map with some configuration attributes for your application, a service, and the application starts. Maybe you scale the application up to three replicas. If one replica dies, Kubernetes automatically recovers it using its built-in control loop mechanism and creates a new one in its place. If you release a new version, you just adjust the deployment configuration, and all replicas get restarted with the new version. You don't need backups because your web application is stateless. Basically, once you deploy the application, you don't have to constantly monitor it to ensure it's running properly. Small adjustments and changes, like updates or scaling up, work without problems because Kubernetes automates these tasks using its control loop mechanism. Kubernetes knows your desired state from your configuration files and continuously tries to match the actual state to your desired state. That's why it automatically recreates a pod that dies or restarts the pods with the updated image version, making the process seamless.

Now for that web application, you need a database for data persistence. For stateful applications like databases, this process isn't as straightforward. These applications need more management throughout their lifecycle. Kubernetes cannot automatically handle stateful applications the way it does with stateless ones. For example, when you create three replicas of a MySQL application, each replica is different with its own state and identity, making things more complex. They need to be updated and destroyed in a specific order, must communicate and synchronize with each other to keep the data consistent, and various other details need to be managed, which differ for each application. MySQL, Postgres, and Elasticsearch each have unique requirements, so there can't be a standard solution in Kubernetes for all these applications.

Typically, stateful applications require manual intervention whether they run on Kubernetes or a traditional server environment, 
requiring people to operate these applications. However, in Kubernetes, manual updates and maintenance conflict with the 
Kubernetes principles of automation, less human intervention, and self-healing attributes. This could lead to preferring 
to host stateful applications outside the Kubernetes cluster. But some stateful applications, like Prometheus monitoring 
or etcd store, are needed within Kubernetes. Therefore, an alternative to managing stateful applications is necessary, 
and that alternative is the operator.

So, what is an operator and how does it solve this problem? An operator replaces the human operator with a software operator. All the manual tasks that a DevOps team or person would do to operate a stateful application are now packed into a program with the knowledge and intelligence about how to deploy that specific application, like Postgres or Prometheus. This program knows how to create a cluster of multiple replicas, how to recover when a replica fails, and so on, automating tasks and making them reusable. If you have two Kubernetes clusters with the same setup, you don't have to manually configure and maintain applications in both environments. Instead, you use one standard automated tool that handles both environments. This automation scales and becomes more beneficial as the complexity of your application and the number of environments increase.

How does an operator do this? At its core, it uses the same control loop mechanism that Kubernetes uses, which watches for changes in the application state. If a replica dies, it creates a new one. If an application configuration changes, it applies the new configuration. If the application image version is updated, it restarts with the new image version. Think of an operator as a custom control loop in Kubernetes. It also uses Custom Resource Definitions (CRDs), which are custom Kubernetes components, to extend Kubernetes' functionality. By default, Kubernetes includes components like deployments and stateful sets. With CRDs, you can create your own custom components. I'll explain CRDs in detail later, but for now, understand that operators build upon Kubernetes' basic resources and controller concepts, adding domain-specific knowledge to automate the lifecycle of the applications they manage.

To summarize, Kubernetes can manage the complete lifecycle of stateless applications in a fully automated way because these applications don't require application-specific logic for deployment or maintenance. Kubernetes doesn't need to know any specific logic to automatically create, update, delete, and maintain these applications. For stateful applications, however, Kubernetes doesn't have all the necessary knowledge to automate their deployment processes, so it uses extensions called operators, with each operator tailored for a specific application.

Who creates these operators? Operators are built by experts with domain-specific knowledge of installing, running, and updating particular applications. For example, a team with knowledge about MySQL creates an operator that knows how to create a MySQL cluster, run it, synchronize replicas, update it, and perform backups. Each application, like Elasticsearch, Prometheus, or etcd, will have its own operator. Many operators are already available, created by the community, which you can use without having to create your own. You can find these operators on websites like OperatorHub or GitHub repositories. If you want to create your own operator, there is an Operator SDK that helps developers or expert teams create operators themselves.
